from scapy.all import *
from scapy.layers.inet import IP, TCP, ICMP
from inputfile import ip_to_scan, port_to_scan, type_of_scan

results = ""  # Global variable to store results

if type_of_scan == "OS":
    def get_ttl(ip):
        """Send an ICMP request to get the TTL value from the response."""
        global results
        try:
            packet = IP(dst=ip) / ICMP()
            response = sr1(packet, timeout=1, verbose=False)
            if response and response.haslayer(IP):  # Ensure response exists
                return response[IP].ttl
        except Exception as e:
            results = f"Error pinging {ip}: {e}"
        return None

    def os_guess_from_ttl(ttl):
        """Estimate OS based on TTL values."""
        if ttl is None:
            return "Unknown"
        elif ttl <= 64:
            return "Linux/Unix-based"
        elif ttl <= 128:
            return "Windows"
        elif ttl <= 255:
            return "Cisco/Networking Device"
        else:
            return "Unknown"

    def get_window_size(ip, port):
        """Send a TCP SYN packet to determine window size."""
        global results
        try:
            packet = IP(dst=ip) / TCP(dport=port, flags="S")
            response = sr1(packet, timeout=2, verbose=False)

            if response and response.haslayer(TCP):  # Check if response exists
                return response[TCP].window

        except Exception as e:
            results = f"Error contacting {ip}: {e}"
        
        return None

    def os_guess_from_window(window):
        """OS determined from TCP Window Size."""
        if window is None:
            return "Unknown"

        os_signatures = {
            8192: "Windows XP/2000/NT",
            16384: "Windows 7/8/10",
            65535: "Windows Server or High-Performance Windows",
            5840: "Linux (2.4 - 3.x kernels)",
            64240: "Linux (Modern 4.x kernels)",
            14600: "FreeBSD/macOS",
            32120: "MacOS X (Lion/Mountain Lion)",
            4128: "Cisco Router/Networking Device",
            8760: "Solaris 7/8/9",
            32768: "OpenBSD",
        }

        if window in os_signatures:
            return f"Likely {os_signatures[window]}"

        # Default ranges
        if 8192 <= window <= 16384:
            return "Possible Windows (XP - 10)"
        elif 5840 <= window <= 64240:
            return "Possible Linux-based OS"
        elif 14600 <= window <= 32120:
            return "Possible macOS/FreeBSD"
        elif window <= 4128:
            return "Possible Cisco/Solaris/Embedded Device"
        
        return "Unknown OS (Uncommon Window Size)"

    def scan_target(ip, port):
        """Scan a single target IP for OS detection."""
        global results
        ttl = get_ttl(ip)
        os_guess = os_guess_from_ttl(ttl)
        window = get_window_size(ip, port)
        os_guess_window = os_guess_from_window(window)

        results = (
            f"Scanning Host: {ip}\n"
            f"  TTL: {ttl} possible detected OS: {os_guess}\n"
            f"  Window Size: {window} possible detected OS: {os_guess_window}\n"
        )

    def get_ip_info():
        """Get IP and port from input file."""
        global results
        try:
            ip = ip_to_scan.strip()
            port = int(port_to_scan)
            return ip, port
        except Exception as e:
            results = f"Error processing input: {e}"
            return None, None

    if __name__ == "__main__":
        ip, port = get_ip_info()
        
        if not ip:
            results = "No valid IP to scan."
        else:
            scan_target(ip, port)

        print(results)  
