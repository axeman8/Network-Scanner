import sys
import socket
from concurrent.futures import ThreadPoolExecutor
from scapy.all import *
from scapy.layers.inet import IP, TCP, ICMP

results = ""

#classic map
def is_host_up(host, ports=[21, 22, 23, 25, 53, 80, 443, 8080, 3306, 3389, 445, 5900]):
    icmp_pkt = IP(dst=host) / ICMP()
    icmp_resp = sr1(icmp_pkt, timeout=1, verbose=False)
    if icmp_resp:
        return True

    for port in ports:
        tcp_pkt = IP(dst=host) / TCP(dport=port, flags="S")
        tcp_resp = sr1(tcp_pkt, timeout=1, verbose=False)
        if tcp_resp and tcp_resp.haslayer(TCP):
            if tcp_resp[TCP].flags == 0x12:
                return True

    return False


def check_host(ip):
    if is_host_up(ip):
        return f"{ip} is up"
    else:
        return f"{ip} is down"
#end of classic map

def scanports(ip, port, open_ports):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((ip, port))
        if result == 0:
            open_ports.append(port)
        sock.close()
    except Exception as e:
        return f"Error scanning port {port} on {ip}: {e}"

def portscan(ip, ports=range(1, 65535)):
    open_ports = []
    
    with ThreadPoolExecutor(max_workers=200) as executr:
        for port in ports:
            executr.submit(scanports, ip, port, open_ports)

    if open_ports:
        return f"Open ports on {ip}: {sorted(open_ports)}"
    else:
        return f"No open ports found on {ip}."

#OS detection
def get_ttl(ip):
    try:
        pkt = IP(dst=ip) / ICMP()
        resp = sr1(pkt, timeout=1, verbose=False)
        if resp and resp.haslayer(IP):
            return resp[IP].ttl
    except Exception as e:
        return f"Error pinging {ip}: {e}"
    return None


def estimated_os_from_ttl(ttl):
    if ttl is None:
        return "Unknown"
    elif ttl <= 64:
        return "Linux/Unix-based"
    elif ttl <= 128:
        return "Windows"
    elif ttl <= 255:
        return "Cisco/Networking Device"
    else:
        return "Unknown"


def get_window_size(ip, port):
    try:
        pkt = IP(dst=ip) / TCP(dport=port, flags="S")
        resp = sr1(pkt, timeout=2, verbose=False)
        if resp and resp.haslayer(TCP):
            return resp[TCP].window
    except Exception as e:
        return f"Error: {e}"
    return None


def estimated_os_from_window(window):
    if window is None:
        return "Unknown"

    os_signatures = {
        8192: "Windows XP/2000/NT",
        16384: "Windows 7/8/10",
        65535: "Windows Server or High-Performance Windows",
        5840: "Linux (2.4 - 3.x kernels)",
        64240: "Linux (Modern 4.x kernels)",
        14600: "FreeBSD/macOS",
        32120: "MacOS X (Lion/Mountain Lion)",
        4128: "Cisco Router/Networking Device",
        8760: "Solaris 7/8/9",
        32768: "OpenBSD",
    }

    if window in os_signatures:
        return f"Likely {os_signatures[window]}"

    if 8192 <= window <= 16384:
        return "Possible Windows (XP - 10)"
    elif 5840 <= window <= 64240:
        return "Possible Linux-based OS"
    elif 14600 <= window <= 32120:
        return "Possible macOS/FreeBSD"
    elif window <= 4128:
        return "Possible Cisco/Solaris/Embedded Device"

    return "Unknown OS"
#end of OS detection

#service version detection
def detect_service_version(ip, target_ports):
    versions = {}
    for port in target_ports:
        try:
            sock = socket.socket()
            sock.settimeout(2)
            result = sock.connect_ex((ip, port))

            if result == 0:
                try:
                    sock.sendall(b"HEAD / HTTP/1.1\r\nHost: " + ip.encode() + b"\r\n\r\n")
                    banner = sock.recv(1024).decode(errors='ignore').split("\n")[0]
                    versions[port] = banner.strip()
                except:
                    versions[port] = "Open, version unknown"
            sock.close()
        except Exception as e:
            versions[port] = f"Error: {str(e)}"
    return versions
#end of service version detection

# Entry point
if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python3 scanner.py <scan_type> <ip> [<port>]")
        sys.exit(1)

    scan_type = sys.argv[1].lower()
    ip = sys.argv[2]
    port = int(sys.argv[3]) if len(sys.argv) > 3 else 80

    if scan_type == "map":
        print(check_host(ip))

    elif scan_type == "os":
        ttl = get_ttl(ip)
        estimated_os = estimated_os_from_ttl(ttl)
        window = get_window_size(ip, port)
        windowsize_os_estimate = estimated_os_from_window(window)

        print(f"Scanning Host: {ip}")
        print(f"  TTL: {ttl} OS based on time to live: {estimated_os}")
        print(f"  Window Size: {window} OS based on window size: {windowsize_os_estimate}")

    elif scan_type == "sv":
        if port == 'default':
            print("Default scan on common ports: [21, 22, 25, 80, 443, 3306, 8080]")
            target_ports = [21, 22, 25, 80, 443, 3306, 8080]
        else:
            target_ports = [port]

        print("\nRunning Service Version Detection\n")
        services = detect_service_version(ip, target_ports)
        for p, svc in services.items():
            print(f"Port {p}: {svc}")
    
    elif scan_type == "port":
        print(portscan(ip))


    else:
        print("Unknown scan type. Use one of: map, os, sv. port")
